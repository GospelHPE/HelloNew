package com.huawei.xdevice.floatrobot.service;

import java.util.List;

import android.app.ActivityManager;
import android.app.ActivityManager.RunningServiceInfo;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.graphics.PixelFormat;
import android.graphics.Rect;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.os.Message;
import android.util.Log;
import android.view.Display;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnTouchListener;
import android.view.WindowManager;
import android.view.WindowManager.LayoutParams;
import android.widget.TextView;

import com.huawei.xdevice.floatrobot.R;
import com.huawei.xdevice.floatrobot.utils.GetEvent;

/**
 * 悬浮窗Service 该服务会在后台一直运行一个悬浮工具窗体
 * 
 * @author sunyl 2017/02/25
 * 
 */
public class FloatEventService extends Service {

	private static final String TAG = FloatEventService.class.getSimpleName();

	public static final int CMD_STOP_SERVICE = 0;

	private static final int UPDATE_PIC = 0x100;

	public static final String ACTION = "com.huawei.xdevice.floatrobot.service.FloatEventService";

	private HandlerUI handler = null;
	private Thread updateThread = null;

	private int statusBarHeight;// 状态栏高度

	private View floatView;// 透明窗体

	private TextView tv;

	private boolean viewAdded = false;// 透明窗体是否已经显示
	private boolean viewHide = false; // 窗口隐藏
	private WindowManager windowManager;
	private WindowManager.LayoutParams layoutParams;

	// private UiDevice uidevice;
	@Override
	public IBinder onBind(Intent arg0) {
		return null;
	}

	@Override
	public void onCreate() {
		super.onCreate();
		System.out.println("****显示event信息Service启动*************");
		// 初始化工具窗口
		createFloatView();
	}

	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {
		return super.onStartCommand(intent, flags, startId);
	}

	@Override
	public void onStart(Intent intent, int startId) {
		super.onStart(intent, startId);
		viewHide = false;
		refresh();
	}

	@Override
	public void onDestroy() {
		super.onDestroy();
		removeView();
	}

	/**
	 * 关闭悬浮窗
	 */
	public void removeView() {
		if (viewAdded) {
			windowManager.removeView(floatView);
			viewAdded = false;
		}
	}

	private void createFloatView() {
		System.out.println("****初始化显示器*************");
		handler = new HandlerUI();
		UpdateUI update = new UpdateUI();
		updateThread = new Thread(update);
		updateThread.start(); // 开户线程

		floatView = LayoutInflater.from(this).inflate(R.layout.toastmain, null);
		tv = (TextView) floatView.findViewById(R.id.mbMessage);
		windowManager = (WindowManager) this.getSystemService(WINDOW_SERVICE);

		final Display display = windowManager.getDefaultDisplay();

		/*
		 * LayoutParams.TYPE_SYSTEM_ERROR：保证该悬浮窗所有View的最上层
		 * LayoutParams.FLAG_NOT_FOCUSABLE:该浮动窗不会获得焦点，但可以获得拖动
		 * PixelFormat.TRANSPARENT：悬浮窗透明
		 */
		layoutParams = new LayoutParams(523, 300,
				LayoutParams.TYPE_SYSTEM_ERROR,
				LayoutParams.FLAG_NOT_FOCUSABLE, PixelFormat.RGBA_8888);
		// layoutParams.type = LayoutParams.TYPE_TOAST;
		// layoutParams.format = PixelFormat.RGBA_8888;
		// layoutParams.flags = LayoutParams.FLAG_NOT_FOCUSABLE;
		// layoutParams.gravity = Gravity.START | Gravity.CENTER;
		layoutParams.x = 0;
		layoutParams.y = 0;
		// 不加flags无法充满全屏
		// layoutParams.flags =
		// WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN;
		// layoutParams.flags = 0x00000008 | 0x00000080 | 0x00000100 |
		// 0x00000200;
		// layoutParams.gravity = Gravity.RIGHT|Gravity.BOTTOM; //悬浮窗开始在右下角显示
		layoutParams.gravity = Gravity.START | Gravity.CENTER;
		// 工具窗口的尺寸固定
		// layoutParams.width = 523;

		/**
		 * 监听窗体移动事件
		 */
		floatView.setOnTouchListener(new OnTouchListener() {
			float[] temp = new float[] { 0f, 0f };

			public boolean onTouch(View v, MotionEvent event) {
				layoutParams.gravity = Gravity.START | Gravity.CENTER;
				final int eventaction = event.getAction();
				switch (eventaction) {
				case MotionEvent.ACTION_DOWN: // 按下事件，记录按下时手指在悬浮窗的XY坐标值
					temp[0] = event.getX();
					temp[1] = event.getY();
					break;
				case MotionEvent.ACTION_MOVE:

					refreshView((int) (event.getRawX() - temp[0]),
							(int) (event.getRawY() - temp[1]));
					break;

				case MotionEvent.ACTION_UP:
					break;
				}
				return true;
			}
		});

	}

	// 判断某个服务是否正在运行的方法
	public boolean isServiceWork(Context mContext, String serviceName) {
		boolean isWork = false;
		ActivityManager myAM = (ActivityManager) mContext
				.getSystemService(Context.ACTIVITY_SERVICE);
		List<RunningServiceInfo> myList = myAM.getRunningServices(200);
		// List<RunningAppProcessInfo> apps = myAM.getRunningAppProcesses();

		if (myList.size() <= 0) {
			return false;
		}

		for (int i = 0; i < myList.size(); i++) {
			String mName = myList.get(i).service.getClassName().toString();
			if (mName.equals(serviceName)) {
				isWork = true;
				break;
			}
		}

		return isWork;
	}

	/**
	 * 刷新悬浮窗
	 * 
	 * @param x
	 *            拖动后的X轴坐标
	 * @param y
	 *            拖动后的Y轴坐标
	 */
	private void refreshView(int x, int y) {
		Log.i(TAG, "*****refreshView********");
		// 状态栏高度不能立即取，不然得到的值是0
		if (statusBarHeight == 0) {
			View rootView = floatView.getRootView();
			Rect r = new Rect();
			rootView.getWindowVisibleDisplayFrame(r);
			statusBarHeight = r.top;
		}

		layoutParams.x = x;
		// y轴减去状态栏的高度，因为状态栏不是用户可以绘制的区域，不然拖动的时候会有跳动
		layoutParams.y = y - statusBarHeight;// STATUS_HEIGHT;
		refresh();
	}

	/**
	 * 添加悬浮窗或者更新悬浮窗 如果悬浮窗还没添加则添加 如果已经添加则更新其位置
	 */
	private void refresh() {
		// 如果已经添加了就只更新view
		if (viewAdded) {
			windowManager.updateViewLayout(floatView, layoutParams);
		} else {
			windowManager.addView(floatView, layoutParams);
			viewAdded = true;
		}
	}

	/**
	 * 接受消息和处理消息
	 * 
	 * @author Administrator
	 * 
	 */
	class HandlerUI extends Handler {
		public HandlerUI() {

		}

		public HandlerUI(Looper looper) {
			super(looper);
		}

		/**
		 * 接收消息
		 */
		@Override
		public void handleMessage(Message msg) {
			System.out.println("****消息 处理*************");
			// TODO Auto-generated method stub
			// 根据收到的消息分别处理
			if (msg.what == UPDATE_PIC) {
				tv.setTag(GetEvent.getEvents());
				// if (!viewHide)
				// refresh();
			} else {
				super.handleMessage(msg);
			}

		}
	}

	/**
	 * 更新悬浮窗的信息
	 * 
	 * @author Administrator
	 * 
	 */
	class UpdateUI implements Runnable {

		@Override
		public void run() {
			System.out.println("****消息发送*************");
			// TODO Auto-generated method stub
			// 如果没有中断就一直运行
			while (!Thread.currentThread().isInterrupted()) {
				Message msg = handler.obtainMessage();
				msg.what = UPDATE_PIC; // 设置消息标识
				handler.sendMessage(msg);
				// 休眠1s
				try {
					Thread.sleep(1000);
				} catch (InterruptedException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
		}
	}
}
